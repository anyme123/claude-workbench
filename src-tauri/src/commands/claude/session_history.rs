use std::fs;
use std::io::{BufRead, BufReader};
use std::path::Path;
use std::time::SystemTime;

use chrono::{DateTime, Utc};
use serde_json::Value;

use super::models::JsonlEntry;
use super::paths::get_claude_dir;

/// Extracts the first valid user message from a JSONL file
pub fn extract_first_user_message<P: AsRef<Path>>(
    jsonl_path: P,
) -> (Option<String>, Option<String>) {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return (None, None),
    };

    let reader = BufReader::new(file);

    for line in reader.lines().map_while(Result::ok) {
        if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
            if let Some(message) = entry.message {
                if message.role.as_deref() == Some("user") {
                    if let Some(content_value) = message.content {
                        // 提取文本内容（支持字符串和数组两种格式）
                        let mut extracted_text = String::new();
                        let mut has_text_content = false;

                        if let Some(text) = content_value.as_str() {
                            // 字符串格式
                            extracted_text = text.to_string();
                            has_text_content = !text.trim().is_empty();
                        } else if let Some(arr) = content_value.as_array() {
                            // 数组格式（可能包含 text 和 tool_result）
                            for item in arr {
                                if let Some(item_type) = item.get("type").and_then(|t| t.as_str()) {
                                    if item_type == "text" {
                                        if let Some(text) =
                                            item.get("text").and_then(|t| t.as_str())
                                        {
                                            extracted_text.push_str(text);
                                            has_text_content = true;
                                        }
                                    }
                                }
                            }
                        }

                        // 必须有文本内容
                        if !has_text_content {
                            continue;
                        }

                        // Skip if it contains the caveat message
                        if extracted_text.contains("Caveat: The messages below were generated by the user while running local commands") {
                            continue;
                        }

                        // Skip if it starts with command tags
                        if extracted_text.starts_with("<command-name>")
                            || extracted_text.starts_with("<local-command-stdout>")
                        {
                            continue;
                        }

                        // Skip Warmup messages (auto-sent on session start)
                        if extracted_text.contains("Warmup") {
                            continue;
                        }

                        // Found a valid user message
                        return (Some(extracted_text), entry.timestamp);
                    }
                }
            }
        }
    }

    (None, None)
}

/// Extracts the timestamp of the last message (user or assistant) from a JSONL file
pub fn extract_last_message_timestamp<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return None,
    };

    let reader = BufReader::new(file);
    let mut last_timestamp: Option<String> = None;

    for line in reader.lines().map_while(Result::ok) {
        if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
            // Check if this entry has a message (user or assistant)
            if entry.message.is_some() {
                // Update last_timestamp if this entry has a timestamp
                if let Some(timestamp) = entry.timestamp {
                    last_timestamp = Some(timestamp);
                }
            }
        }
    }

    last_timestamp
}

/// Extracts the model used in the session from a JSONL file
/// Looks for model information in system init messages or assistant messages
pub fn extract_session_model<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return None,
    };

    let reader = BufReader::new(file);
    let mut last_model: Option<String> = None;

    for line in reader.lines().map_while(Result::ok) {
        // Try to parse as a generic JSON value first
        if let Ok(entry) = serde_json::from_str::<Value>(&line) {
            // Check for model in different locations:
            // 1. System init message: { "type": "system", "model": "..." }
            // 2. Assistant message: { "type": "assistant", "message": { "model": "..." } }

            if let Some(model_str) = entry.get("model").and_then(|m| m.as_str()) {
                last_model = Some(model_str.to_string());
            } else if let Some(message) = entry.get("message") {
                if let Some(model_str) = message.get("model").and_then(|m| m.as_str()) {
                    last_model = Some(model_str.to_string());
                }
            }
        }
    }

    last_model
}

/// Loads the JSONL history for a specific session
pub fn load_session_history(session_id: &str, project_id: &str) -> Result<Vec<Value>, String> {
    log::info!(
        "Loading session history for session: {} in project: {}",
        session_id,
        project_id
    );

    let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
    let session_path = claude_dir
        .join("projects")
        .join(project_id)
        .join(format!("{}.jsonl", session_id));

    if !session_path.exists() {
        return Err(format!("Session file not found: {}", session_id));
    }

    // Get file modification time as base timestamp
    let file_metadata =
        fs::metadata(&session_path).map_err(|e| format!("Failed to read file metadata: {}", e))?;
    let base_time = file_metadata
        .modified()
        .unwrap_or_else(|_| SystemTime::now());

    let file =
        fs::File::open(&session_path).map_err(|e| format!("Failed to open session file: {}", e))?;

    let reader = BufReader::new(file);
    let mut messages = Vec::new();

    for line in reader.lines().map_while(Result::ok) {
        if let Ok(json) = serde_json::from_str::<Value>(&line) {
            messages.push(json);
        }
    }

    // Add timestamps to historical messages that don't have them
    let messages_count = messages.len();
    for (i, message) in messages.iter_mut().enumerate() {
        let message_type = message.get("type").and_then(|t| t.as_str()).unwrap_or("");

        // Calculate timestamp for this message (5 second intervals, older messages get earlier timestamps)
        let time_offset = (messages_count - i - 1) as u64 * 5; // 5 seconds between messages
        let message_time = base_time - std::time::Duration::from_secs(time_offset);
        let timestamp_iso = DateTime::<Utc>::from(message_time).to_rfc3339();

        // Set appropriate timestamp fields based on message type, only if they don't exist
        match message_type {
            "user" => {
                if message.get("sentAt").is_none() {
                    message["sentAt"] = Value::String(timestamp_iso.clone());
                }
            }
            "assistant" | "system" | "result" => {
                if message.get("receivedAt").is_none() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
            _ => {
                // For unknown types, add receivedAt
                if message.get("receivedAt").is_none() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
        }
    }

    Ok(messages)
}
